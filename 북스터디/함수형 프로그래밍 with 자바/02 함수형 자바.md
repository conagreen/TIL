# 함수형 자바

2장에서는 자바에서 람다를 활용하는 방법, 중요성, 효과적인 사용법과 작동 원리에 대해 살펴본다.

## 자바 람다란?

코드가 한 줄 또는 블록 단위로 이루어져 있으며 0개 이상의 매개변수를 갖고 값을 반환할 수 있다. 아래 예시와 같이 어떠한 객체에도 속하지 않는 익명 메서드와 비슷하다.

```java
Runnable hello = () -> System.out.println("hello!");
```

> (< parameters >) -> { < body > }
>

이 문법은 세 가지 부분으로 구성된다.

**매개변수**

컴파일러가 매개변수의 타입을 추론할 수 있는 경우 매개변수의 타입을 생략할 수 있다. 단, 매개변수가 하나인 경우에는 괄호를 생략할 수 있지만 없거나 둘이상인 경우에는 괄호를 사용해야 한다.

**화살표**

화살표는 람다의 매개변수와 바디를 구분하기 위해 사용한다.

**바디**

람다 바디는 단일 표현식 또는 코드 블록으로 구성된다. 한 줄의 코드로만 작성된 표현식은 중괄호를 사용하지 않아도 되며 계산된 결과는 암시적으로 return 문 없이 반환된다.

```java
// 1. 가장 기본적인 방식
Function<String, Boolean> lamda = (String value) -> {
		return value == null;
};

// 2. 매개변수에 대한 타입과 괄호 생략
Function<String, Boolean> lamdaWithoutType = value -> {
	return value == null;
};

// 3. 중괄호와 return 문 생략
Function<String, Boolean> lamdaWithoutReturn = (String value) -> value == null;

// 4. 가장 간단하게 표현 (2번 + 3번)
Function<String, Boolean> simpleLamda = value -> value == null;
```

### 함수형 인터페이스

람다 표현식이 자바에서 일급 객체로 취급받기 위해서는 기존의 객체와 비슷한 표현 방식을 갖추어야 한다. **일급함수**와 **고차함수**처럼, 람다 표현식은 특화된 인터페이스의 하위 타입으로 표현된다. 이렇게 특화된 인터페이스를 **함수형 인터페이스**라고 한다.

함수형 인터페이스에는 별도의 문법이나 키워드가 없다. 그렇다면 ‘함수형 인터페이스’로 만드는 조건은 무엇일까? 바로 SAM(Single Abstract Method) 이라는 특성을 만족해야 한다. SAM은 추상 메서드 한 개를 가진 인터페이스의 특성을 의미한다. 기본(default) 메서드나 정적(static) 메서드는 추상 메서드가 아니기 때문에, 여러 개 존재해도 상관없다.

- **메서드 시그니처:** 인터페이스에는 반드시 구현되어야 하는 추상 메서드 시그니처가 포함됨. 이러한 메서드 시그니처는 함수형 인터페이스의 단일 추상 메서드 제약에 부합함
- **기본 메서드:** 인터페이스를 구현하는 모든 클래스가 이를 재정의할 수 있지만 필수는 아님
- **정적 메서드:** 클래스 레벨에서 필수적으로 구현되어야 하는 메서드이며, 기본 메서드와는 달리 상속되지 않음

### 람다와 외부 변수

람다는 순수 함수와 참조 투명성처럼 외부 상태에 영향을 주지 않는 순수한 함수의 개념을 따르지만, 유연성을 위해 어느 정도의 불순성을 허용한다. 람다는 ‘**캡처’** 를 통해 람다가 정의된 생성 스코프 내의 상수와 변수를 획득할 수 있다. 원래의 스코프가 더 이상 존재하지 않더라도 이러한 변수들을 사용할 수 있다.

캡처 람다와 논캡처 람다의 주요 차이점은 JVM 최적화 전략에 있다. 변수가 캡처되지 않은 경우 람다는 내부적으로 간단한 정적 메서드가 될 수 있지만, 변수를 캡처하는 상황에서 JVM은 다양한 방식으로 코드를 변환할 수 있다. 이로 인해 추가적인 객체 할당이 발생하며, 이는 성능 및 GC 시간에 영향을 줄 수 있다. 캡처가 본질적으로 나쁜 설계 방식은 아니지만 최소한의 객체 할당 또는 최고의 성능이 필요한 경우에는 불필요한 사용은 피하는 것이 좋다.

**Effectively final**

캡처되는 변수는 반드시 Effectively final 이어야 한다. 어떤 변수든 초기화된 이후에 값이 한 번도 변경되지 않았다면 final 키워드를 사용하지 않더라도  effective final 이라고 할 수 있다. 이러한 변수는 final 키워드를 명시적으로 사용하거나 초기화된 이후에 상태가 변경되지 않도록 유지해야 한다.

effective final 이 아닌 참조를 람다 내에서 사용해야 한다면 해당 참조를 다시 final로 만들어서 사용할 수 있다. 하지만 참조를 다시 final 로 바꾸는 것은 임시 방편일 뿐 임시 방편이 필요하다는 것은 이미 어딘가 문제가 발생했다는 신호다. 코드를 리팩토링하거나 재설계하는 것이 참조를 다시 final로 만드는 등의 트릭을 사용하는 것보다 항상 더 나은 선택지가 될 것이다.

```java
// 해당 시점에서는 nonEffectivelyFinal은 effectively final 이다.
int nonEffectivelyFinal = 1000;

// 변수를 변경하였기 때문에 더 이상 effectively final이 아님. 람다에서 사용할 수 없다.
nonEffectivelyFinal = 500;

// effectively final 의 변수 생성한 후 람다에서 사용
int finalAgain = nonEffectivelyFinal;
Predicate<Integer> isOver500 = input -> input > finalAgain;
```


## 람다의 실전 활용

### 메서드 참조

자바 8에서는 람다 외에도 새로운 기능을 소개했다. 람다 표현식을 생성하는 새로운 방법인 **메서드 참조**이다. 새로운 연산자인 ‘::’(이중 콜론)을 사용하여 기존의 메서드를 참조하는 간결한 문법 설탕으로, 기존의 메서드로부터 람다 표현식을 생성하는 대신 기존의 메서드를 참조하여 함수형 코드를 보다 간소화하는 역할을 한다.

> **문법 설탕이란?**
문법 설탕은 프로그래밍 언어의 부가 기능으로, 개발자가 일상을 더욱 ‘달콤하게’ 만들기 위해 도입되었다. 문법 설탕은 특정 구조를 더 간결하고 명확하게 표현할 수 있는 대안을 제시한다.
>

**정적 메서드 참조**

정적 메서드 참조는 일반적으로 `ClassName::staticMethodName` 모양으로 사용된다. 특정 타입의 정적 메서드를 가리킨다.

```java
Function<String, Integer> parseInt = Integer::parseInt;
```

**바운드 비정적 메서드 참조**

바운드 비정적 메서드 참조는 특정 객체의 인스턴스 메서드를 참조한다. 이 메서드 참조는 해당 객체에 바인드되어 있기 때문에 '바운드'라고 불린다.

```java
String str = "conagreen";
Supplier<Integer> stringLength = str::length;
```

**언바운드 비정적 메서드 참조**

언바운드 비정적 메서드 참조는 특정 객체에 바인드되지 않은 인스턴스 메서드를 참조한다. 이는 첫 번째 인수로 메서드 참조 대상 객체를 받는다.

```java
Function<String, Integer> stringLength = String::length;
```

위의 예제에서 `String::length`는 인스턴스 메서드를 참조하지만 특정 객체에 바인드되지 않는다. 대신, `stringLength` 함수는 `String` 객체를 받아 그 길이를 반환한다.

**생성자 참조**

생성자 참조는 클래스의 생성자를 참조하여 새로운 객체를 생성하는 메서드 참조이다. 이는 `ClassName::new` 모양으로 사용된다.

```java
Supplier<List<String>> listSupplier = ArrayList::new;
```

## 자바의 함수형 프로그래밍 개념

### 함수 합성

객체 지향 프로그래밍에서는 더 작은 객체들로 구성되어 더 복잡한 API 를 설계할 수 있다. 함수형 프로그래밍에서는 두 함수가 결합되어 새로운 함수를 구현한 후 다른 함수들과 다시 결합할 수 있다. 함수 합성은 함수형 프로그래밍 사고방식 중 가장 핵심적인 개념이다. 작고 재사용 가능한 함수들은 더 큰 체인으로 조합하여 더 복잡한 작업을 수행하는 시스템을 구축한다.

함수 합성을 쉽게 알려줄 수 있는 이미지 첨부

**느긋한 계산법**

원칙적으로 자바는 느긋하지 않고 엄격하고 열성적인 언어이지만 여러 가지 느긋한 구조를 지원한다.

- 논리적 단축 계산 연산자 (`boolean result = (x == 0) && (x / 2 == 0);`)
- if-else 및 :? (삼항) 연산자
- for 및 while 루프 연산자

## 회고

무지하게 사용했던 자바의 기능들을 이번 2장을 통해 이해할 수 있었다. 특히 자바의 레코드 같은 경우 본문에는 따로 내용을 기재하지 않았지만, 77p에서 아래와 같이 설명한다. 단순히 레코드 클래스는 데이터를 변경할 수 없는 상황에서 사용하려고 지향했지만 이러한 패러다임을 이해하니 앞으로 기능을 사용할 때 좀 더 깊이 있는 접근이 가능해졌다.

> **불변성** (77p)
>
> 다른 프로그래밍 언어와 비교하면 자바는 불변성에 대한 지원이 비교적 제한적입니다. 따라서 effectively final과 같은 구조를 강제로 사용해야 합니다. 완전 불변성을 가지려면 처음부터 자료 구조를 불변으로 설계해야 하지만 이는 번거롭고 오류가 발생하기 쉽습니다.
> …
> 자바 14+ 에서는 불변 데이터 클래스인 **레코드**가 도입되어 이러한 격차를 줄이는 데 도움이 되었다.
>

이번 장을 통해 배운 것들을 바탕으로, 앞으로의 학습에서도 이 개념들을 계속 확장하고 적용해 나갈 것이다.
