## 인덱스란?

인덱스(index)는 데이터베이스 테이블의 검색 성능을 높이기 위해 사용되는 자료구조이다. 인덱스는 책의 목차처럼 책의 내용을 빠르게 찾기 위해 목차를 이용하듯, 데이터베이스에서 데이터를 빠르게 찾기 위해 인덱스를 사용한다.

## 인덱스 특징

### 장점

- **빠른 검색**: 인덱스를 사용하면 검색 성능이 크게 향상된다. 특히 대량의 데이터를 다루는 경우, 인덱스의 유무에 따라 성능 차이가 크다.
- **정렬된 결과**: 인덱스를 사용하면 데이터를 정렬된 상태로 유지할 수 있어 정렬 작업이 필요 없는 경우가 많다.
- **유니크 인덱스**: 중복된 값을 허용하지 않도록 유니크 인덱스를 설정할 수 있다

### 단점

- **쓰기 성능 저하**: 인덱스가 많을수록 데이터 삽입, 업데이트, 삭제 시 인덱스를 갱신해야 하므로 쓰기 성능이 저하될 수 있다.
- **저장 공간 증가**: 인덱스는 추가적인 저장 공간을 필요로 하기 때문에 인덱스가 많을수록 디스크 사용량이 증가한다.
- **복잡한 관리**: 인덱스의 수가 많아지면 관리가 복잡해질 수 있다. 인덱스의 필요성과 성능을 주적으로 점검해야 한다

### 인덱스를 타지 않는 경우

- 인덱스 컬럼의 변형 - 인덱스 컬럼에 함수나 연산을 적용하는 경우
- 부정 연산자 사용 - 부정 연산자 (`!=`, `<>`, `NOT IN`, `NOT LIKE`)를 사용하는 경우 인덱스가 사용되지 않을 수 있음
- 와일드 카드 사용 - LIKE 연산자를 사용할 때 와일드카드를 컬럼의 앞에 사용하는 경우
- 옵티마이저의 선택 - 전체 테이블 스캔이 더 효율적이라고 판단하는 경우

<aside>
💡 옵티마이저: 데이터베이스 옵티마이저(Optimizer)는 SQL 쿼리를 실행할 때 최적의 실행 계획을 선택하는 데이터베이스 구성요소로, 여러 실행 계획 중에서 가장 효율적인 계획을 선택하여 쿼리 성능을 최적화한다.

</aside>

## 인덱스의 종류

### 1. B-Tree 인덱스

- **특징**: 대부분의 데이터베이스에서 기본적으로 사용하는 인덱스 구조로, 균형 트리 형태임
- **장점**: 검색, 삽입, 삭제, 범위 검색에 효율적
- **단점**: 데이터가 무작위로 삽입될 경우 성능이 저하될 수 있음

### 2. Hash 인덱스

- **특징**: 해시 함수를 사용하여 데이터를 저장
- **장점**: 정확한 값 검색에 효율적
- **단점**: 범위 검색이나 정렬된 결과를 제공하지 못함

### 3. Full-text 인덱스

- **특징**: 텍스트 검색에 특화된 인덱스
- **장점**: 대량의 텍스트 데이터를 효율적으로 검색함
- **단점**: 인덱스 크기가 매우 커질 수 있음

### 4. Spatial 인덱스

- **특징**: 공간 데이터 (지리 정보 등) 검색에 사용
- **장점**: 위치 기반 검색에 효율적
- **단점**: 복잡한 공간 데이터에 대해 성능이 저하될 수 있음

## 인덱스의 동작 원리

### B-Tree 인덱스

가장 일반적인 인덱스 구조로 B-Tree 인덱스는 균형 이진 트리 구조를 사용하여 데이터를 정렬하고, 데이터 접근을 최적화하며, 아래와 같은 동작 원리를 가진다.

1. **노드**: B-Tree는 노드들로 구성되며, 각 노드는 키와 포인터를 포함
2. **균형**: 트리의 높이는 균형을 이루며, 모든 리프 노드는 동일한 깊이를 가짐
3. **탐색**: 특정 값을 찾기 위해 루프 노드부터 시작하여 키를 비교하고, 자식 노드로 이동하여 탐색

### Hash 인덱스

Hash 인덱스는 해시 함수를 사용하여 키를 해싱하고, 그 결과로 데이터를 저장하는 구조다. 해시 인덱스는 특정 값의 정확한 매칭을 빠르게 찾는 데 유용하지만, 범위 검색에는 적합하지 않다.

## 카디널리티

### 카디널리티란?

카디널리티(Cardinality)는 데이터베이스 테이블에서 특정 컬럼의 고유 값 개수를 의미한다. 높은 카디널리티는 많은 고유 값을 가지며, 낮은 커디널리티는 적은 고유 값을 가진다. 카디널리티는 인덱스의 효율성에 중요한 영향을 미치기 때문에 높은 카디널리티 컬럼에 인덱스를 설정하면 검색 성능이 향상될 수 있지만, 낮은 카디널리티 컬럼에 인덱스를 설정하면 그 효과가 제한적일 수 있다.

- **높은 카디널리티**: 고객 ID, 주민등록번호 처럼 중복되는 값이 없거나 적은 데이터
- **낮은 카디널리티**: 성별, Boolean 자료형처럼 중복되는 값이 많은 데이터

## 인덱스 문법

### 인덱스 생성

```sql
CREATE [UNIQUE] INDEX idx_column_name ON table_name(column_name);
```

### 인덱스 삭제

```sql
DROP INDEX idx_column_name ON table_name;
```

### 인덱스 재구성

```sql
ALTER INDEX idx_column_name REBUILD;
```

### 인덱스 조회

```sql
SHOW INDEX FROM table_name;
```

## 결론

인덱스는 데이터베이스 성능을 개선하는 강력한 도구이지만, 무조건 많은 인덱스를 설정한다고 해서 항상 좋은 것은 아니다. 인덱스는 추가적인 DB 공간을 필요로 하며, 데이터 변경 작업 시 오히려 성능 저하를 초래할 수 있기 때문에 꼭 필요한 컬럼에만 인덱스를 생성해야 한다. 조회 시 자주 사용하는 컬럼이나 카디널리티가 높은 컬럼 위주로 설정하는 것이 좋다.

삽입이나 수정이 빈번히 일어나는 컬럼에는 인덱스 사용을 신중히 고려해야 한다. 인덱스가 설정된 컬럼에 데이터 변경이 발생하면 인덱스 테이블의 재정렬이 발생하기 때문에 이러한 작업이 빈번할 경우 전체 성능이 저하될 수 있다. 따라서, 인덱스는 주로 UPDATE가 빈번하지 않은 컬럼에 설정하는 것을 잊지말자.